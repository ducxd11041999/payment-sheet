// Filename: main.go
package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"os"
	"time"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"

	_ "my-source/sheet-payment/be/docs"

	"github.com/google/uuid"

	fiber "github.com/gofiber/fiber/v2"
	"github.com/gofiber/swagger"
	_ "github.com/swaggo/files"
)

// @title Expense Tracker API
// @version 1.0
// @description API for managing shared expenses by month
// @host localhost:3000
// @BasePath /

// @contact.name Bui Phung Huu Duc
// @contact.email ducbph.x@gmail.com

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

type Member struct {
	ID      string  `json:"id"`
	BlockID string  `json:"block_id"`
	Name    string  `json:"name"`
	Ratio   float64 `json:"ratio"`
	Debt    int     `json:"debt"`
}

type Transaction struct {
	ID          string             `json:"id"`
	BlockID     string             `json:"block_id"`
	Description string             `json:"description"`
	Amount      int                `json:"amount"`
	Payer       string             `json:"payer"`
	Details     map[string]int     `json:"details"`
	Ratios      map[string]float64 `json:"ratios"`
	CreatedAt   time.Time          `json:"created_at"`
}

type Block struct {
	ID           string         `json:"id"`
	Month        string         `json:"month"`
	Locked       bool           `json:"locked"`
	Members      []*Member      `json:"members"`
	Transactions []*Transaction `json:"transactions"`
}

var db *sql.DB

func initDB() {
	var err error
	dsn := os.Getenv("DATABASE_URL")
	if dsn == "" {
		dsn = "host=pgdb port=5432 user=postgres password=yourpassword dbname=expenses sslmode=disable"
	}
	db, err = sql.Open("postgres", dsn)
	if err != nil {
		log.Fatal(err)
	}

	queries := []string{
		`CREATE TABLE IF NOT EXISTS blocks (
			id TEXT PRIMARY KEY,
			month TEXT UNIQUE,
			locked BOOLEAN
		)`,
		`CREATE TABLE IF NOT EXISTS members (
			id TEXT PRIMARY KEY,
			block_id TEXT,
			name TEXT,
			ratio FLOAT,
			debt INT,
			FOREIGN KEY (block_id) REFERENCES blocks(id)
		)`,
		`CREATE TABLE IF NOT EXISTS transactions (
			id TEXT PRIMARY KEY,
			block_id TEXT,
			payer TEXT,
			amount INT,
			description TEXT,
			created_at TIMESTAMP,
			ratios JSONB,
			FOREIGN KEY (block_id) REFERENCES blocks(id)
		)`,
		`CREATE TABLE IF NOT EXISTS transaction_details (
			transaction_id TEXT,
			member_id TEXT,
			amount INT,
			PRIMARY KEY (transaction_id, member_id)
		)`,
	}
	for _, q := range queries {
		if _, err := db.Exec(q); err != nil {
			log.Fatal(err)
		}
	}
}

// @Summary Get all transactions for a block
// @Tags transactions
// @Produce json
// @Param month path string true "Month"
// @Success 200 {array} Transaction
// @Router /blocks/{month}/transactions [get]
func getTransactionsByBlock(c *fiber.Ctx) error {
	month := c.Params("month")
	row := db.QueryRow(`SELECT id FROM blocks WHERE month = $1`, month)
	var blockID string
	if err := row.Scan(&blockID); err != nil {
		return fiber.ErrNotFound
	}

	txRows, err := db.Query(`SELECT id, description, amount, payer, created_at, ratios FROM transactions WHERE block_id = $1`, blockID)
	if err != nil {
		return err
	}
	defer txRows.Close()

	txns := []Transaction{}
	for txRows.Next() {
		var tx Transaction
		var ratiosJson []byte
		tx.BlockID = blockID
		tx.Details = map[string]int{}
		tx.Ratios = map[string]float64{}
		err := txRows.Scan(&tx.ID, &tx.Description, &tx.Amount, &tx.Payer, &tx.CreatedAt, &ratiosJson)
		if err != nil {
			return err
		}
		_ = json.Unmarshal(ratiosJson, &tx.Ratios)

		detailRows, err := db.Query(`SELECT member_id, amount FROM transaction_details WHERE transaction_id = $1`, tx.ID)
		if err != nil {
			return err
		}
		for detailRows.Next() {
			var mid string
			var amt int
			detailRows.Scan(&mid, &amt)
			tx.Details[mid] = amt
		}
		detailRows.Close()
		txns = append(txns, tx)
	}

	return c.JSON(txns)
}

// @Summary Get all members
// @Tags members
// @Produce json
// @Success 200 {array} Member
// @Router /members [get]
func getAllMembers(c *fiber.Ctx) error {
	rows, err := db.Query(`SELECT id, block_id, name, ratio, debt FROM members`)
	if err != nil {
		return err
	}
	defer rows.Close()

	members := []Member{}
	for rows.Next() {
		var m Member
		rows.Scan(&m.ID, &m.BlockID, &m.Name, &m.Ratio, &m.Debt)
		members = append(members, m)
	}
	return c.JSON(members)
}

// @Summary Lock a block
// @Tags blocks
// @Param month path string true "Month"
// @Success 200 {string} string "locked"
// @Router /blocks/{month}/lock [post]
func lockBlock(c *fiber.Ctx) error {
	month := c.Params("month")
	_, err := db.Exec(`UPDATE blocks SET locked = true WHERE month = $1`, month)
	if err != nil {
		return err
	}
	return c.SendString("locked")
}

// @Summary Unlock a block
// @Tags blocks
// @Param month path string true "Month"
// @Success 200 {string} string "unlocked"
// @Router /blocks/{month}/unlock [post]
func unlockBlock(c *fiber.Ctx) error {
	month := c.Params("month")
	_, err := db.Exec(`UPDATE blocks SET locked = false WHERE month = $1`, month)
	if err != nil {
		return err
	}
	return c.SendString("unlocked")
}

// @Summary Get summary of member debts in a block
// @Tags blocks
// @Produce json
// @Param month path string true "Month"
// @Success 200 {object} map[string]int
// @Router /blocks/{month}/summary [get]
func getSummary(c *fiber.Ctx) error {
	month := c.Params("month")
	row := db.QueryRow(`SELECT id FROM blocks WHERE month = $1`, month)
	var blockID string
	if err := row.Scan(&blockID); err != nil {
		return fiber.ErrNotFound
	}

	rows, err := db.Query(`SELECT name, debt FROM members WHERE block_id = $1`, blockID)
	if err != nil {
		return err
	}
	defer rows.Close()

	summary := map[string]int{}
	for rows.Next() {
		var name string
		var debt int
		rows.Scan(&name, &debt)
		summary[name] = debt
	}
	return c.JSON(summary)
}

// @Summary Add a transaction to a block
// @Tags transactions
// @Accept json
// @Produce json
// @Param month path string true "Month"
// @Param body body object true "Transaction info"
// @Success 200 {object} map[string]interface{}
// @Router /blocks/{month}/transactions [post]
func addTransaction(c *fiber.Ctx) error {
	month := c.Params("month")
	row := db.QueryRow(`SELECT id, locked FROM blocks WHERE month = $1`, month)
	var blockID string
	var locked bool
	if err := row.Scan(&blockID, &locked); err != nil {
		return fiber.ErrNotFound
	}
	if locked {
		return fiber.ErrForbidden
	}
	type Req struct {
		Amount       int                `json:"amount"`
		Description  string             `json:"description"`
		Payer        string             `json:"payer"`
		Participants map[string]float64 `json:"participants"`
	}
	var req Req
	if err := c.BodyParser(&req); err != nil {
		return err
	}
	totalWeight := 0.0
	for _, w := range req.Participants {
		totalWeight += w
	}
	if totalWeight == 0 {
		return fiber.NewError(fiber.StatusBadRequest, "participants weight must be > 0")
	}

	ranID := uuid.New().String()
	created := time.Now()
	ratiosJSON, _ := json.Marshal(req.Participants)
	_, err := db.Exec(`INSERT INTO transactions (id, block_id, payer, amount, description, created_at, ratios) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		ranID, blockID, req.Payer, req.Amount, req.Description, created, ratiosJSON)
	if err != nil {
		return err
	}

	for memberID, weight := range req.Participants {
		share := int(float64(req.Amount) * (weight / totalWeight))
		_, err := db.Exec(`INSERT INTO transaction_details (transaction_id, member_id, amount) VALUES ($1, $2, $3)`, ranID, memberID, share)
		if err != nil {
			return err
		}
		if memberID == req.Payer {
			_, _ = db.Exec(`UPDATE members SET debt = debt + $1 WHERE id = $2`, req.Amount-share, memberID)
		} else {
			_, _ = db.Exec(`UPDATE members SET debt = debt - $1 WHERE id = $2`, share, memberID)
		}
	}

	return c.JSON(fiber.Map{"id": ranID, "block_id": blockID, "created_at": created})
}

// @Summary Create a new block
// @Tags blocks
// @Accept json
// @Produce json
// @Param body body map[string]interface{} true "Month and members"
// @Success 200 {object} Block
// @Router /blocks [post]
func createBlock(c *fiber.Ctx) error {
	type Req struct {
		Month   string   `json:"month"`
		Members []Member `json:"members"`
	}
	var req Req
	if err := c.BodyParser(&req); err != nil {
		return err
	}

	id := uuid.New().String()
	_, err := db.Exec(`INSERT INTO blocks (id, month, locked) VALUES ($1, $2, $3)`, id, req.Month, false)
	if err != nil {
		return err
	}

	members := []*Member{}
	for _, m := range req.Members {
		m.ID = uuid.New().String()
		m.BlockID = id
		m.Debt = 0
		m.Ratio = 0 // deprecated
		members = append(members, &m)
		_, err := db.Exec(`INSERT INTO members (id, block_id, name, ratio, debt) VALUES ($1, $2, $3, $4, $5)`, m.ID, id, m.Name, m.Ratio, m.Debt)
		if err != nil {
			return err
		}
	}

	return c.JSON(Block{ID: id, Month: req.Month, Locked: false, Members: members})
}

// @Summary Get members of a specific block
// @Tags members
// @Produce json
// @Param month path string true "Month"
// @Success 200 {array} Member
// @Router /blocks/{month}/members [get]
func getMembersByBlock(c *fiber.Ctx) error {
	month := c.Params("month")
	row := db.QueryRow(`SELECT id FROM blocks WHERE month = $1`, month)
	var blockID string
	if err := row.Scan(&blockID); err != nil {
		return fiber.ErrNotFound
	}

	rows, err := db.Query(`SELECT id, block_id, name, ratio, debt FROM members WHERE block_id = $1`, blockID)
	if err != nil {
		return err
	}
	defer rows.Close()

	members := []Member{}
	for rows.Next() {
		var m Member
		if err := rows.Scan(&m.ID, &m.BlockID, &m.Name, &m.Ratio, &m.Debt); err != nil {
			return err
		}
		members = append(members, m)
	}
	return c.JSON(members)
}

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found or error loading it")
	}
	initDB()
	app := fiber.New()

	app.Get("/swagger/*", swagger.HandlerDefault)
	app.Post("/blocks", createBlock)
	app.Post("/blocks/:month/transactions", addTransaction)
	app.Get("/blocks/:month/transactions", getTransactionsByBlock)
	app.Get("/blocks/:month/summary", getSummary)
	app.Get("/members", getAllMembers)
	app.Post("/blocks/:month/lock", lockBlock)
	app.Post("/blocks/:month/unlock", unlockBlock)
	app.Get("/blocks/:month/members", getMembersByBlock)

	log.Fatal(app.Listen(":3000"))
}
